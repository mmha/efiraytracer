<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Morris Hafner (@mmha)">
  <title>UEFI Applications with C++</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">UEFI Applications with C++</h1>
  <p class="author">Morris Hafner (<span class="citation" data-cites="mmha">@mmha</span>)</p>
  <p class="date">emBO++ 8th March 2018</p>
</section>

<section id="what-is-uefi" class="slide level2">
<h2>What is (U)EFI?</h2>
<ul>
<li>“New” firmware interface for x86, ARM, RISC-V</li>
<li>Many features compared to BIOS
<ul>
<li>Network, Secure Boot, NVRAM, EFI Bytecode, …</li>
</ul></li>
<li>No assembly required for many applications (e. g. bootloaders)</li>
</ul>
</section>
<section id="efi-executables" class="slide level2">
<h2>EFI executables</h2>
<ul>
<li>COFF file format, subsystems 10-13</li>
<li>MS calling convention</li>
<li>UTF-16 strings</li>
<li>On a FAT32 partition with partition type <code>0xEF00</code></li>
<li>Implementations usually default to executing <code>EFI/Boot/bootx64.efi</code></li>
</ul>
</section>
<section><section id="first-executable" class="title-slide slide level1"><h1>First Executable</h1></section><section id="toolchain" class="slide level2">
<h2>Toolchain</h2>
<ul>
<li>TianoCore EDK II, gnu efilib</li>
<li>We will use gnu efilib, it is easier to use</li>
<li>Available compilers: MSVC, MinGW gcc</li>
<li>No clang
<ul>
<li>Doesn’t support freestanding COFF executables</li>
</ul></li>
</ul>
</section><section id="standard-library" class="slide level2">
<h2>Standard Library</h2>
<ul>
<li>no C or C++ standard library
<ul>
<li>A C95 stdlib implementation is part of EDK II</li>
</ul></li>
<li>Heap not easily accessible</li>
<li>In practice, many headers can still be used
<ul>
<li>most of <code>&lt;algorithm&gt;</code>, <code>&lt;array&gt;</code>,<code>&lt;tuple&gt;</code>,<code>&lt;type_traits&gt;</code></li>
</ul></li>
<li>See Ben Craig’s talk and proposal (p0829r1) to fix this</li>
</ul>
</section><section id="compiler-invocation" class="slide level2">
<h2>Compiler Invocation</h2>
<pre><code>x86_64-w64-mingw32-g++ \
  -mno-red-zone -DEFI_FUNCTION_WRAPPER \
  -ffreestanding -fshort-wchar \ 
  -nostdlib -e efi_main \
  -Wl,-dll -shared -Wl,--subsystem,10 \
  -c main.cpp</code></pre>
<p>This can be wrapped in a CMake Toolchain</p>
</section><section id="the-code" class="slide level2">
<h2>The code</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;efi.h&gt;</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;efilib.h&gt;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="at">extern</span> <span class="st">&quot;C&quot;</span> [[<span class="at">gnu::ms_abi</span>]]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">EFI_STATUS efi_main(</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  IN EFI_HANDLE ImageHandle,</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  IN EFI_SYSTEM_TABLE *SystemTable)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">{</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    SystemTable-&gt;ConOut-&gt;OutputString(</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      SystemTable-&gt;ConOut,</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">      (CHAR16 *) <span class="st">L&quot;Hello World</span><span class="sc">\r\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">}</a></code></pre></div>
</section><section id="running-it" class="slide level2">
<h2>Running it</h2>
<p>OVMF is an OSS implementation that can be used with QEMU</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ex">qemu-system-x86_64</span> \</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">-drive file=hdd.img,if=ide \</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">-bios OVMF.fd</a></code></pre></div>
</section></section>
<section><section id="accessing-efi-services" class="title-slide slide level1"><h1>Accessing EFI Services</h1></section><section id="the-efi-protocol-interface" class="slide level2">
<h2>The EFI Protocol Interface</h2>
<ul>
<li>Firmware services can be queried using GUIDs</li>
<li>Everything is loaded into structs</li>
<li>OO style interface, but in C with function pointers</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" data-line-number="1">EFI_STATUS</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">LocateDevicePath (</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"> IN     EFI_GUID                 *Protocol,</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"> IN OUT EFI_DEVICE_PATH_PROTOCOL **DevicePath,</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"> OUT    EFI_HANDLE               *Device</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"> );</a></code></pre></div>
</section><section id="hmmm" class="slide level2">
<h2>Hmmm…</h2>
<p>Signature is usually</p>
<p><code>EFI_STATUS(in..., inout *..., out *...)</code></p>
<p>In C++, we want this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" data-line-number="1">expected&lt;tuple&lt;out...&gt;, EFI_STATUS&gt;</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="at">const</span> res = func(in <span class="at">const</span>..., inout &amp;...);</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="cf">if</span>(res) {</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">   <span class="kw">auto</span>[out...] = res.value();</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">}</a></code></pre></div>
</section><section id="what-to-do" class="slide level2">
<h2>What to do?</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="dt">size_t</span> in_count, <span class="dt">size_t</span> inout_count,</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">          <span class="dt">size_t</span> out_count = SIZE_MAX, <span class="kw">typename</span> Callable&gt;</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">auto</span> wrap(Callable c);</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">auto</span> locate_device_path =</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  wrap&lt;<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>&gt;(LocateDevicePath);</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">expected&lt;tuple&lt;EFI_HANDLE&gt;, EFI_STATUS&gt; result =</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  locate_device_path(protocol, device_path);</a></code></pre></div>
<ol type="1">
<li>Partition the argument list</li>
<li>Create a new function wrapping the EFI function</li>
<li>Wrap the error codes</li>
</ol>
</section><section id="getting-the-argument-list" class="slide level2">
<h2>Getting the Argument List</h2>
<p>→ Boost Callable Traits</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" data-line-number="1">EFI_STATUS</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">LocateDevicePath(EFI_GUID *,</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    EFI_DEVICE_PATH_PROTOCOL **,</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    EFI_HANDLE *);</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="pp">#include </span><span class="im">&lt;boost/callable_traits/args.hpp&gt;</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">using</span> args =</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">  <span class="ex">boost::</span>callable_traits<span class="ex">::</span>args_t&lt;<span class="kw">decltype</span>(LocateDevicePath)&gt;;</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="kw">static_assert</span>(is_same_v&lt;args,</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  tuple&lt;EFI_GUID *,</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">        EFI_DEVICE_PATH_PROTOCOL **,</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">        EFI_HANDLE *&gt;</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">);</a></code></pre></div>
</section><section id="partition-the-argument-list" class="slide level2">
<h2>Partition the Argument List</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="dt">size_t</span> offset, <span class="kw">typename</span> T, <span class="dt">size_t</span>... I&gt;</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">auto</span> <span class="kw">constexpr</span> st_impl(T tuple, index_sequence&lt;I...&gt;) {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="cf">return</span> tuple{get&lt;offset + I&gt;(tuple)...};</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">template</span> &lt;<span class="dt">size_t</span> N, <span class="kw">typename</span> T&gt;</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">auto</span> <span class="kw">constexpr</span> split_tuple(T tuple) {</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  <span class="kw">auto</span> <span class="kw">constexpr</span> sz = tuple_size_v&lt;T&gt;;</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  <span class="cf">return</span> tuple{</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    st_impl&lt;<span class="dv">0</span>&gt;(tuple, make_index_sequence&lt;N&gt;{}),</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    st_impl&lt;N&gt;(tuple, make_index_sequence&lt;sz - N&gt;{}),</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  };</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">}</a></code></pre></div>
</section><section id="way-split" class="slide level2">
<h2>3-way split</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">using</span> in_split =</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">decltype</span>(split_tuple&lt;in_count&gt;(declval&lt;args&gt;()));</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">using</span> In = <span class="co">// &lt;- first</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="dt">tuple_element_t</span>&lt;<span class="dv">0</span>, in_split&gt;;</a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">using</span> InOut_Out =</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="dt">tuple_element_t</span>&lt;<span class="dv">1</span>, in_split&gt;;</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">using</span> inout_out_split =</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  <span class="kw">decltype</span>(split_tuple&lt;inout_count&gt;(declval&lt;InOut_Out&gt;()));</a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="kw">using</span> InOut = <span class="co">// &lt;- second</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  <span class="dt">tuple_element_t</span>&lt;<span class="dv">0</span>, inout_out_split&gt;;</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"><span class="kw">using</span> Out = <span class="co">// &lt;- third</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  <span class="dt">tuple_element_t</span>&lt;<span class="dv">1</span>, inout_out_split&gt;;</a></code></pre></div>
</section><section id="wrap-the-function" class="slide level2">
<h2>Wrap the Function</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> Func,</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">typename</span>... Is, <span class="kw">typename</span>... IOs, <span class="kw">typename</span>... Os&gt;</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">auto</span> <span class="kw">constexpr</span> make_out_param_adapter(</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  Func func, tuple&lt;Is...&gt;, tuple&lt;IOs...&gt;, tuple&lt;Os...&gt;) {</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="cf">return</span> [func](Is... is, IOs... ios) {</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">      tuple&lt;<span class="dt">remove_pointer_t</span>&lt;Os&gt;...&gt; res;</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">      <span class="kw">auto</span> <span class="at">const</span> ptr = transform_tuple(res, [](<span class="kw">auto</span> &amp;val) {</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">        <span class="cf">return</span> addressof(val);</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">      });</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">      apply(c, tuple_cat(</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">        tuple{get_ptr(is)...}, tuple{get_ptr(ios)...}, ptr));</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">      <span class="cf">return</span> res;</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    };</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">}</a></code></pre></div>
</section><section id="overhead" class="slide level2">
<h2>Overhead?</h2>
<iframe width="100%" height="500px" src="https://godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(fontScale:2.6748301344767995,j:1,lang:c%2B%2B,source:'%23include+%3Ctuple%3E%0Aextern+%22C%22+void+f(int+*out)%3B%0Aint+c()+%7B%0A++++int+r%3B%0A++++f(%26r)%3B%0A++++return+r%3B%0A%7D%0Aauto+cpp()+%7B%0A++++std::tuple%3Cint%3E+r%3B%0A++++f(%26std::get%3C0%3E(r))%3B%0A++++return+r%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:60,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:clang600,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'0',undefined:'1'),fontScale:2.2290251120639994,lang:c%2B%2B,libs:!(),options:'-std%3Dc%2B%2B17+-O3',source:1),l:'5',n:'0',o:'x86-64+clang+6.0.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),k:40,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">
</iframe>
</section><section id="aligned_storage" class="slide level2">
<h2><code>aligned_storage</code>!</h2>
<p><code>std::tuple</code> causes value initialization</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span> storage_for {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  storage_for() {}</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">auto</span> get() {</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="cf">return</span> <span class="kw">reinterpret_cast</span>&lt;T *&gt;(&amp;val);</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  }</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="dt">aligned_storage_t</span>&lt;<span class="kw">sizeof</span>(T), <span class="kw">alignof</span>(T)&gt; val;</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">};</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" data-line-number="1">tuple&lt;storage_for&lt;<span class="dt">remove_pointer_t</span>&lt;Os&gt;&gt;...&gt; res;</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">auto</span> <span class="at">const</span> ptr = transform_tuple(res, [](<span class="kw">auto</span> &amp;val) {</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="cf">return</span> val.get();</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">});</a></code></pre></div>
</section><section id="wrap-the-error-codes" class="slide level2">
<h2>Wrap the error codes</h2>
<ul>
<li><code>expected&lt;T, E&gt;</code> contains either a value or an error</li>
<li>We use <code>tl::expected&lt;T, E&gt;</code> (thanks, Simon!)</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="cf">if</span> <span class="kw">constexpr</span>(</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  is_same_v&lt;<span class="dt">invoke_result_t</span>&lt;Func, Is..., IOs..., Os...&gt;,</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">            EFI_STATUS&gt;) {</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">using</span> <span class="dt">result_t</span> =</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    tl::expected&lt;tuple&lt;<span class="dt">remove_pointer_t</span>&lt;Os&gt;...&gt;, EFI_STATUS&gt;;</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  <span class="cf">if</span>(<span class="kw">auto</span> result = apply(...) != EFI_SUCCESS)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    <span class="cf">return</span> <span class="dt">result_t</span>(tl::unexpect, result);</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  <span class="cf">return</span> <span class="dt">result_t</span>{transform_tuple(...)};</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  apply(...);</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  <span class="cf">return</span> res;</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">}</a></code></pre></div>
</section><section id="wrap-the-pointers" class="slide level2">
<h2>Wrap the pointers</h2>
<p>We can modify the signature to accept references</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" data-line-number="1">EFI_STATUS func(<span class="dt">int</span> *inout);</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="dt">int</span> x{};</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">wrap&lt;<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>&gt;(func)(x);</a></code></pre></div>
<p>Create a struct constructible with a reference and a pointer</p>
</section><section id="overhead-1" class="slide level2">
<h2>Overhead?</h2>
<iframe width="100%" height="500px" src="https://godbolt.org/e#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAOgA4BWAOz8ATAAYAnCIBsgzhIUTBpAFZdSrZrVDIApCIBC%2Bg6QDOqAK7FkHAOT6AzHlrJWFrAGpdDgMIAjVFRTAgB6FlZNP3YAfQJiZkJTEOZiYFNuBAAHTO9sXTEAQUdnV3dML18qCxcCPDo2XPyikScXN09vHwQCAkzTEBCQ%2BIB3bmBCBAs/C1NMazoCTHpuNABbEIAVFIItABlNVeYQzAAPTMxkRfQQw%2BC5kIJWY7OLq4zsxsLitrKKnwILJl2J9mq1Sh1fAQAJ7nWLxRIgpozZzADzYABiAElogwNgUNgBVBgVAAiHmcBG8Ri%2BhUWqyBzEWf1MeAAXphYh5UFQqLMCKQPNDzrRmKtyhsBSz2bFuLKPJiQcwLEQPGhaHczsQPKYgYRYoCYnh6awIBsvDJ9NIAUDMJKCOgQCBnFgTtFZgBHCxLGydTGy7i5ACUHloqFONkyBAgofDmEjEGCDpA1uBgmpBQ8me19sdwEwlN83N5%2BfNBnluQTOZANGIwxS6E6GwrKcwgcD/t0ghJba8aaaWY8xHzVlo2aTLc7BkTufznSLfNL5Yc2ErSZrdeIDd8TeXEBbbY7XapTU7JJPtMwxsZ5U6Uo5BA8ADkBUKlqLxYrlahVXQNZktTqrB6i2prmtIlr7iGYYnBGUYxjBcZRtOyYGpgk79lmgHAah0RGkCnRiBWyHrvWjbNqhgZ2kmhwANYcs6pxupgnremhviPo0fZdpRGGZlhBD6jauHGp0HG7sRJAbluPg7iu%2B5UY6tH0bQLpMSxLhsT4yEtm6bIcgAbreVZYCwUKxGRy65B4AC0T6cUY3GkCe3HBuhNISEqKpqn%2BAGsqSY6Ojpd7RIZvjISZzBmQWMmNJZDjpvkEhDgCxCjtpqFuUUkiJfxgmGiJviEeJVYkZuFlyRRCkgEpuEqYxHpehpon2aePHuTluoCTpeGsM1xVrpJpHbuRNqUQF1XMHRtWqQ1rG3n5tliXkXHdk57VHvFzlnjSBR0gyTKdK%2BIpih4GyoS%2BMJvidAAKQ7oFVwUEP6S55IU3mLJqHied%2BcRaKYNarHl9HGqaqFgRBAq3Zg6DgzImRVQxrqzU1vh%2BrKQZQbG8bwbBq6BRlfaFAOEm1kNPhQ1uK6ZIGeMgHm0UKv1jqldJZ02s2bbtujLm9umA7JSO40TmmJNSZ0FMVtTtP076RElYNZXbhlu4EJzh5nptXxHjte2aAdkKXcd4rnYKhvvh4EuWW9v4ff%2BX1foK8TqgDQOgzasNWpDd0e9TmMIfGvF%2B7jv3OyQgPdSDotk2zwIq21GYDonSfJynmHy6Tivk3dkvx6nef58TVY1YjamNT6YVVkFekhUZSZDqsqD6RyQ5UHMrHmUr7NxXklkrZzvOBwLqWO39LsR0CtMs42ytyWNUeZ5bVO5wXK9J8hxd1UjzFl5p6VCcFoVaVW9eN83mCt0OGkdzJM%2BxctDndseWvbVlu2XvtN4G8K5uYrQF3fydX%2BAB5ZU/8rrlBAfyU2ADyg%2BDYJEWOr0CjBGIBYS4XJlTREyCkUU0RmDoGYJGOYT9X662vH8I65tZJNBQWgh8wQSDMDzNEGsA93LIm0NAz%2BZIdwJUkO9U4dsGHxGYTWCArlCZZQkKec8EgBGfW%2Bh4em4ig6ITYVIxKQ9RxDgpHMf8%2BZogsGCI2DwAAqCslp9JsEDCQxKMj3LyLtoo5RwZ3qqMjOouxkgtGDkwLo4g%2BiBJGOimaNx5jdyWOsbY7K2tX4Dn/HgKxiwQCB2QmwPAwBaDQzdEQER95bx6W5KaMa6TMlFI2DY5cHgrG9U1kUDafDSHvz1p/f4ZsxTPUxKYMBRtOlAO6Vw3pcp%2Bk9PNnAiIzAohsSQbQ9BlgBLYPiIDfBhDFjEFrvjLuPgukdmXFVCcqN%2Bm7OwPs5WPgjnoz2R4cZCDpmeP4TbQRWp5lYJwcsghRDiAQBuZM9gqp4G/NbO4yk7kBwgFVLTBuTcIDhFuT2TKdjYmyMcQBSuZzkInyblg1A/jr79NyMcrk5x4i5PERALpHtnp4AGZifplK5R1FMK4m2wL7nSMkHvWOR9GGiJIBskAmKOSZBxfQOYeLTB30JUOCVdSvEeQdm4yMWpvBkhDv9MOrtpUCl0PwIw/ASQQEUZE1gEi%2BHsvNT4nRoqAnJUMcwYxX9wHjQilFToJlWCvggDUyp2BAqXTMXLJM%2BD0DSvMFQL11jKlmsRY/WV2UOVVkIUCKEMKXw4RYEhNF7MRbpzFqjGVK5qVcwDF2U52apy5rJrSgtEBGXFtPAKJVbZokWuHMPNVY9UIQCVdq3VOqDVGpkN63mviUqjlMTUqkvZY3RqRQ4x5n1OW72PpeU%2B2LcXRXxcuQlqBiWMhIGSillpLRUppXS49MgqVBGDCEUxrLTEhFkQi%2BNEgl1GR5RyGs/LBXruteKyVlzsC%2BJldGyQijFVxH8h2jVIEtVeD7fqw1DtjWmqfS%2By1fjrWBLtQ6tpMDnUXEitfd1nrvW5D9ecANTMQDBtDUU71Ua0PSO4i2nKibsisBTcgNNQkM202FhWgaGdpJdIrEW9WZbUyCeZgrETW7C3Xokx4JtjH2reLbaOaDxBw5dp7fBvVA7kNDusSOnxE6GjxWnapjRc6E6ZgSUkjggcflTNVLYhp54mlXn1v8Zp5DDrtLuZQk6EpBnmwJCCFFHgAioFYOSUwtVghaBsP5KgbBZjRLft51pZCfPBaC4F06oyToRatgUKLMW4vUsSzsFGMkBQ7h8KVnuQGVWOy9Jl3LOXCvUMKLMh8SqW5sqi4N8%2B4jZFguU9EaMFgIhNrZfY1%2BiURtxBbrTWgs3WBKtiDY0FWZwWZGmxtubcRUPrRfrIrrFDCvNeRQuu2o3w0EjAr7HGiEJv7amxAS0vtn3MYu%2B5K7AX8O3fneqW2WpHsQGe6Y170FYIfczAd6bv3JExs88t%2B7zy925NOmYlRbi3seL%2B5ojTU3WO2cx%2BDp5ePTEuJ/OD1lJP1NjvJ3G/7nn4nEESdeFJRMsxmlh9EdzGtGlA8dUbU6kWsf2xVPTLBcRQIXqtMGInD4/t4CoAznytaEvOCS3Vx7VUXXX2ocuM7GiWeC3nqzDmYx8zjfZ6eDwmBWCzAW1b9tFOLu2fF3hp1vWCgcNREOBkNgFfKocGSZCap8C1HqKwa%2ByFqvCtxYfWSjbVvn2/aurFqe/0hLvg12KYu/N5cKy59gxXMCdIGflvpdfAvPXk00cDMuaovMWbglZnzvkAtc8r2FgK1p2dXmPteWauU7MA9r9XMgR/j8X4nN9hz0gz7cZaBfS/t8r/OWvgMVSN8yAt/zMnOqDDIH8jbzolfpkwv7%2BwGxiHQ%2BaHD0q30phZ9WXeqegUL/mBv5xC%2BjyZXpMrqIpy77CJMKfp8oVx1y55CoiprL/rdxSqYAgaBwDht6M5KpQZOzqraaaroG9oGZIYqgobgH5wYb%2BLYbBLA5OrhSEauq%2BAkaXQRomrkbJj%2BrhIrhpLoAhroFhrsHNp1IpytQkIpya6z5PK0zVamDvg1xwGOjOD6SoBTTSqzZdQ34P62jyj74CjVr%2BgCgXIH4nJohYg4h4iEgMAYyZQFzB7AaaGchtaPCOiCKvDQz8oHJHzwFQqIEbqdAgGAYCgYjYi4j4hEgl6YHJzYHBCOEepX7sbJqpqCjpqMj8YEwGDy5Kq671qlpCyZHZGK51pKYqYSH5ya4QAaEJFgBgBtZiAn5j4YamBOFRiuEgDVDuGXB/7oGaHWYFyLYFzNGtGThaY6Y2jdpxAkH9pkHfgUGTijqCzma1JljiEeb85JzO6u7u52H5xpIcZcY8YxB8ZvpphFFfLibcwkiSZoRnEGI5ElFXGZ7EAiF8xUFk7SrlGbGxIDgyKyq%2B5l6tKPTki0CGKWD0CSjVwPjOAvJoDVBQLAmwngnq5R4eAMCYgABa2A0QAAsgUAABrV7XI6GfheQy7DDxCZB94TID4WgyDICq7w5qJ/YOEsiZKMhWDcLRaBDBCOhD5TJwgJAED9A0apAJbRS35RHsIsicLOBuidT%2BSsHnAJidRAydBylwn0CBqOjuqTphQZIigpR36cwtoOG/yJHjg4Su6XhLBaGFQChyn8RSlSJmm0CQLRCQIWmbIxDWlij0DXycAOmglOlxRmoOEwmYIvL8SKkXAepsG5TeERlBLInakgC6kWbbJumYKQIVgmlxoukymojALKhekoRCS%2Bm2nXxiBBkvJRmdTOmJQOGeltZLrRAVn%2BnRSBkgm1mYIhk9xmo%2BId6YJd7vKrJzCTyybaE0mIIwpjS/zoT5HFmUgrTGHKgLkzpbSeZ%2B715yiB7hmjgtmT6aQbDHIkLblN67kgj7nzKlneEnmAZnmAnXYwLPR7mFkYIonR5HmNinn5mnBrIHkiAiA%2BD6AiAgkPjIBVAuC1oQngVmJBkPimLWaxEQ4eAUlJrQz%2BToU5C%2BBdl4UViQXVAMmZbFBUBYBa6PjYAADq0QAAEkAhsJRQwDYYUKoXgDDMgNkCorsZmBSF9OuQKH4OuV8bLt%2BG4tUZ%2BWhZSecOgIaoJf0VmJURJY0UnChfpnoPqv5KYhJSJVzhSOGqBS0cgDYKYJ/voPwA2EBQKMRaIVmIMVmNsTeJIinGpXMJHmSBJdwG5QegpUnAkvQAZUBWlngHFuZZZSIAKG5b5dOpuV8C0EsPgFQBji0JruRR4EArsCSNEAUI%2BFlQYESBsNgC/GxRxdxc5YpfQPxSudFgJW5rZZmIohJf5IRdBcwNqjIH4O1dIDZW8bxeGk1SqvUSpYnP5QQIFSIEZSZWZSIBZaBdZdFfZZmI5ZQX5dzgFd9kFQkKFTNeFT0S0R6gtUikivFSpJrrYJRKwCALYPwLYKQLQFdWILdagFdSBYYMYNqJYNYDeC0JwLdQQA9edZRDRCAAACwiDcAiASC8AOBiDiASAg0SCcDSCBmXW2Ag23X3W2CPWkDPW2C3X9DVn/VY3nWkBwCwBIBrCZAhVzDkCUCU3U3EB0yCAOCkBUAhVrL9AQB%2BAA2kB%2BDOApBQhXW/WkBrB%2BkEBAK0CcY81YCHDaDsDS14BDiXCJLoE82nAXDKh2DC26Ko3Y1xBGgA2UQ0D0BMBsAcDg1AUSCw38CcCcDiDSAOCKAg0aBaA6DGDGAaB4B%2BD9CwBGwgAxbBCkBNyM22BI3SCA042Rh1DqhXXWSJgqp6BvWGCcCCA2RAIOA2QkiUU0X0WMXYDMWZjWRUChjWTEA9B4A2SHDWAIAqqGkq02TF2oDWRYzx7qj42fU2BcAXVXU3V3U8240nC8DSDWTSAg1KLGUeCCDcAZ0QC4CEAkDmgOBdk%2BCoD0gM2L2cDBivVGCGB/WG1A0gBiDcCCAg0g2iBAWcAw2CAiCCDSA20aBXXo193E041XX42H2kBE2PWURk2IAoCr1U3sBkAUAwoAMM1M0s1s0epzCc3c0v180ijECC2h23Wi22kS1S0v0y2u3y1YOK2vAq39Av3q3ICa1C23U608362rCG2s0LCm3y0W2Q3W22322O0KDO2aDaAoDu2GCe3e3wDRjvj%2B08n8jB1C3SDh1tiR2t1ENx32gJ28MGAp1p0Z3WQkgZVZU5V5UFVFWF2N2l3l2V0pDIA11R511Nzt1WCd2b0P3XUY391XWD3D2j3j2X5T0z1z246ODL1gNAOL0iBb1KN73E3SPA1H38C8AI3w0OAOAg3Q0CDQ0s2o1P2Y3Y243v2E20O/0QBICJVUC03UD0PhAcA8ACDCBw0yByCKBKAaAID9CBnED1MgCBN2O91pNPVXUkia5a7OMj1j3AAT0ePVKf59OuODPuPT0hPf0H38DSDT3X2cC8CX1CAp0zW8B2OpOON41mAf1f0R2o0iAOMv0ZOf371B0wPR2g1AA%3D">
</iframe>
</section><section id="we-made-simplifications" class="slide level2">
<h2>We made simplifications</h2>
<ul>
<li>Assumptions that there are only builtins and PODs
<ul>
<li>All argument types need trivial destructors</li>
</ul></li>
<li>Cannot be overloaded</li>
<li>Not too bad, C doesn’t have overloads or destructors</li>
<li>But may be wrapped by a future <code>std::overload</code></li>
<li>Future high level wrappers may implement overloads</li>
</ul>
</section></section>
<section><section id="example-application" class="title-slide slide level1"><h1>Example application</h1></section><section id="rendering-to-the-framebuffer" class="slide level2">
<h2>Rendering to the Framebuffer</h2>
<ul>
<li>We could write our own kernel in C++ now…
<ul>
<li><code>ExitBootServices()</code></li>
</ul></li>
<li>Let’s render a couple of spheres onto the framebuffer instead</li>
</ul>
</section><section id="creating-a-graphics-out-protocol-instance" class="slide level2">
<h2>Creating a Graphics Out Protocol Instance</h2>
<p>First, some wrappers</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">// Look for GOP implementations</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">auto</span> locate_handle_buffer =</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  wrap&lt;<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">1</span>&gt;(bootServices-&gt;LocateHandleBuffer);</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="co">// Create a GOP Instance</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="kw">auto</span> handle_protocol =</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  wrap&lt;<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>&gt;(bootServices-&gt;HandleProtocol);</a></code></pre></div>
</section><section id="yay-monads" class="slide level2">
<h2>Yay, monads!</h2>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">uint64_t</span> handle_count = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">auto</span> maybe_gop =</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">locate_handle_buffer(ByProtocol, graphicsOutProtocolGUID,</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">                     <span class="kw">nullptr</span>, handle_count)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"> .and_then([&amp;](<span class="kw">auto</span> proto_impl) {</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">     <span class="cf">return</span> handle_protocol(get&lt;<span class="dv">0</span>&gt;(proto_impl)[<span class="dv">0</span>],</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">                            graphicsOutProtocolGUID);</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"> })</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"> .map([](<span class="kw">auto</span> opened_gop) {</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">     <span class="cf">return</span> <span class="kw">reinterpret_cast</span>&lt;EFI_GRAPHICS_OUTPUT_PROTOCOL *&gt;(</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">        get&lt;<span class="dv">0</span>&gt;(opened_gop));</a>
<a class="sourceLine" id="cb16-12" data-line-number="12"> });</a>
<a class="sourceLine" id="cb16-13" data-line-number="13"><span class="cf">if</span>(!maybe_gop)</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">  conOut-&gt;OutputString(conOut, (CHAR16*) <span class="st">u&quot;Fail</span><span class="sc">\r\n</span><span class="st">&quot;</span>);</a></code></pre></div>
<p>FACT: This slide contains error handling</p>
</section><section id="a.-sagar-p0931r0" class="slide level2">
<h2>A. Sagar: p0931r0</h2>
<p>Structured bindings with polymorphic lambdas</p>
<p>To be discussed in Jacksonville</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="bu">std::</span>find_if(range, [](<span class="kw">auto</span> <span class="at">const</span>&amp; [key, value]) {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="cf">return</span> examine(key, value);</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">});</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">locate_handle_buffer(ByProtocol, graphicsOutProtocolGUID,</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">                     <span class="kw">nullptr</span>, handleCount)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7"> .and_then([&amp;](<span class="kw">auto</span> [proto_impl]) {</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">     <span class="cf">return</span> handle_protocol(proto_impl[<span class="dv">0</span>],</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">                            graphicsOutProtocolGUID);</a>
<a class="sourceLine" id="cb17-10" data-line-number="10"> });</a></code></pre></div>
</section><section id="create-the-framebuffer" class="slide level2">
<h2>Create the Framebuffer</h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" data-line-number="1">gop = maybe_gop.value();</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="kw">auto</span> query_mode = wrap&lt;<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>&gt;(gop-&gt;QueryMode);</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>;; ++i) {</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="kw">auto</span> mode_info = query_mode(gop, i)</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  .map([](<span class="kw">auto</span> r)-&gt;<span class="kw">decltype</span>(<span class="kw">auto</span>){<span class="cf">return</span> *<span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(r);});</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="cf">if</span>(!mode_info) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  <span class="cf">if</span>(mode_info-&gt;HorizontalResolution == width &amp;&amp;</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">     mode_info-&gt;VerticalResolution == height &amp;&amp;</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">     mode_info-&gt;PixelFormat ==</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">     PixelBlueGreenRedReserved8BitPerColor) {</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">       gop-&gt;SetMode(gop, i);</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">       <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">}</a></code></pre></div>
</section><section id="use-the-framebuffer" class="slide level2">
<h2>Use the Framebuffer</h2>
<p>With emulated double buffering</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="dt">void</span> swap_to_screen() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="kw">auto</span> <span class="at">const</span> pixel_ptr =</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    <span class="kw">reinterpret_cast</span>&lt;<span class="dt">uint32_t</span> *&gt;(gop-&gt;Mode-&gt;FrameBufferBase);</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  <span class="cf">for</span>(<span class="kw">auto</span> <span class="at">const</span>&amp; row : rows) {</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    <span class="bu">std::</span>copy(row.begin(), row.end(), pixel_ptr);</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    pixel_ptr += gop-&gt;Mode-&gt;Info-&gt;PixelsPerScanLine;</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  }</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="dt">void</span> clear() {</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">  <span class="cf">for</span>(<span class="kw">auto</span> &amp;row : rows) {</a>
<a class="sourceLine" id="cb19-11" data-line-number="11">    <span class="bu">std::</span>fill(row.begin(), row.end(), T{});</a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">}</a></code></pre></div>
</section><section id="implicit-surfaces" class="slide level2">
<h2>Implicit Surfaces</h2>
<p>Remember: Avoided heap</p>
<p>Implicit surfaces using signed distance fields offer a functional representation of a scene</p>
<p>Unfortunately no time for details</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">auto</span> scene = [](vec3 <span class="at">const</span>&amp; rayT) {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="cf">return</span> pUnion(sphere(vec3( <span class="fl">10.0</span>, <span class="fl">0.0</span>, <span class="dv">50</span>), <span class="dv">20</span>, rayT),</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">                sphere(vec3(<span class="dv">-10</span><span class="fl">.0</span>, <span class="fl">5.0</span>, <span class="dv">50</span>), <span class="dv">20</span>, rayT));</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">};</a></code></pre></div>
</section><section id="references" class="slide level2">
<h2>References</h2>
<ul>
<li><a href="https://github.com/mmha/efiraytracer">github.com/mmha/efiraytracer</a></li>
<li><a href="https://github.com/TartanLlama/expected/">github.com/TartanLlama/expected</a></li>
<li><a href="https://wiki.osdev.org/UEFI_Bare_Bones">OSDev Wiki: UEFI Bare Bones</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0829r1.html">P0829r1: Freestanding Proposal</a></li>
<li><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0931r0.pdf">P0931r0: Structured bindings with polymorphic lambdas</a></li>
</ul>
</section></section>
<section><section id="live-demo" class="title-slide slide level1"><h1>Live Demo</h1></section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/math/math.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
